-- Таблица пользователей
CREATE TABLE Users (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name NVARCHAR2(50) NOT NULL,
    last_name NVARCHAR2(50) NOT NULL,
    email NVARCHAR2(100) UNIQUE NOT NULL,
    hash NVARCHAR2(255) NOT NULL,
    role NVARCHAR2(20) CHECK (role IN ('admin', 'user', 'employee')) NOT NULL
);

-- Таблица жанров книг
CREATE TABLE genres (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name NVARCHAR2(50) UNIQUE NOT NULL
);

-- Таблица авторов
CREATE TABLE authors (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name NVARCHAR2(100) NOT NULL,
    biography CLOB
);

-- Таблица книг
CREATE TABLE book (
    id_book NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title NVARCHAR2(255) NOT NULL,
    price NUMBER(10,2) NOT NULL,
    stock NUMBER DEFAULT 0 NOT NULL,
    genre_id NUMBER NULL,
    description CLOB,
    publication_date DATE NULL,
    author_id NUMBER NULL,
    CONSTRAINT fk_book_genre FOREIGN KEY (genre_id) REFERENCES genres(id) ON DELETE SET NULL,
    CONSTRAINT fk_book_author FOREIGN KEY (author_id) REFERENCES authors(id) ON DELETE SET NULL
);

-- Таблица сотрудников
CREATE TABLE employee (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name NVARCHAR2(50) NOT NULL,
    last_name NVARCHAR2(50) NOT NULL,
    job NVARCHAR2(100) NOT NULL
);

-- Таблица заказов
CREATE TABLE Orders (
    id_order NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id NUMBER NULL,
    price NUMBER(10,2) NOT NULL,
    count NUMBER NOT NULL,
    employee_id NUMBER NULL,
    CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES Users(id) ON DELETE CASCADE,
    CONSTRAINT fk_orders_employee FOREIGN KEY (employee_id) REFERENCES employee(id) ON DELETE SET NULL
);

-- Таблица деталей заказа
CREATE TABLE orderdetails (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id NUMBER NOT NULL,
    product_id NUMBER NOT NULL,
    count NUMBER NOT NULL,
    date_order TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT fk_orderdetails_order FOREIGN KEY (order_id) REFERENCES Orders(id_order) ON DELETE CASCADE,
    CONSTRAINT fk_orderdetails_product FOREIGN KEY (product_id) REFERENCES book(id_book) ON DELETE CASCADE
);

-- Таблица платежей
CREATE TABLE payments (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id NUMBER NOT NULL,
    sum NUMBER(10,2) NOT NULL,
    CONSTRAINT fk_payments_order FOREIGN KEY (order_id) REFERENCES Orders(id_order) ON DELETE CASCADE
);

CREATE INDEX idx_book_title ON book(title);
CREATE INDEX idx_orders_user ON Orders(user_id);

-- Создание представлений
CREATE VIEW vw_books AS
SELECT b.id_book, b.title, b.price, b.stock, g.name AS genre, a.name AS author, b.publication_date
FROM book b
LEFT JOIN genres g ON b.genre_id = g.id
LEFT JOIN authors a ON b.author_id = a.id;

CREATE VIEW vw_orders AS
SELECT o.id_order, u.name || ' ' || u.last_name AS customer, o.price, o.count, e.name || ' ' || e.last_name AS employee
FROM Orders o
LEFT JOIN Users u ON o.user_id = u.id
LEFT JOIN employee e ON o.employee_id = e.id;
-- Индексы для таблицы Users
CREATE INDEX idx_users_email ON Users (email);
CREATE INDEX idx_users_role ON Users (role);

-- Индексы для таблицы genres
CREATE INDEX idx_genres_name ON genres (name);

-- Индексы для таблицы authors
CREATE INDEX idx_authors_name ON authors (name);

-- Индексы для таблицы book
CREATE INDEX idx_book_title ON book (title);
CREATE INDEX idx_book_genre ON book (genre_id);
CREATE INDEX idx_book_author ON book (author_id);
CREATE INDEX idx_book_price ON book (price);
CREATE INDEX idx_book_stock ON book (stock);

-- Покрывающий индекс для book с дополнительными полями (без CLOB)
CREATE INDEX idx_book_title_covering ON book (title, id_book, price, stock, genre_id, author_id, publication_date);

-- Индексы для таблицы employee
CREATE INDEX idx_employee_name ON employee (name);
CREATE INDEX idx_employee_last_name ON employee (last_name);

-- Индексы для таблицы Orders
CREATE INDEX idx_orders_user ON Orders (user_id);
CREATE INDEX idx_orders_employee ON Orders (employee_id);
CREATE INDEX idx_orders_price ON Orders (price);
CREATE INDEX idx_orders_count ON Orders (count);

-- Индексы для таблицы orderdetails
CREATE INDEX idx_orderdetails_order ON orderdetails (order_id);
CREATE INDEX idx_orderdetails_product ON orderdetails (product_id);

-- Покрывающий индекс для orderdetails с дополнительными полями
CREATE INDEX idx_orderdetails_order_covering ON orderdetails (order_id, product_id, count, date_order);

-- Индексы для таблицы payments
CREATE INDEX idx_payments_order ON payments (order_id);

-- Если нужно индексировать колонку типа CLOB (например, description в таблице book), используйте полнотекстовый индекс
CREATE INDEX idx_book_description ON book (description) 
    INDEXTYPE IS CTXSYS.CONTEXT;

-- Дополнительные составные индексы (composite indexes) для повышения производительности запросов

-- Составной индекс для Orders с дополнительными полями
CREATE INDEX idx_orders_user_covering ON Orders (user_id, id_order, price, count, employee_id);

-- Составной индекс для book с дополнительными полями
CREATE INDEX idx_book_genre_author_covering ON book (genre_id, author_id, id_book, price, stock);

-- Запрос с использованием EXPLAIN PLAN для анализа, какой индекс будет использован
EXPLAIN PLAN FOR
SELECT * FROM Users WHERE email = 'ivanov@example.com';

-- Вывод плана выполнения запроса
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


INSERT INTO Users (name, last_name, email, hash, role) VALUES 
('Иван', 'Иванов', 'ivanov@example.com', 'hash1', 'user');

INSERT INTO Users (name, last_name, email, hash, role) VALUES 
('Петр', 'Петров', 'petrov@example.com', 'hash2', 'admin');

INSERT INTO Users (name, last_name, email, hash, role) VALUES 
('Сергей', 'Сергеев', 'sergeev@example.com', 'hash3', 'employee');

INSERT INTO Users (name, last_name, email, hash, role) VALUES 
('Анна', 'Сидорова', 'sidorova@example.com', 'hash4', 'user');

INSERT INTO Users (name, last_name, email, hash, role) VALUES 
('Мария', 'Козлова', 'kozlova@example.com', 'hash5', 'user');

INSERT INTO genres (name) VALUES ('Фантастика');
INSERT INTO genres (name) VALUES ('Детектив');
INSERT INTO genres (name) VALUES ('Роман');
INSERT INTO genres (name) VALUES ('Научная литература');
INSERT INTO genres (name) VALUES ('Фэнтези');

INSERT INTO authors (name, biography) VALUES ('Артур Кларк', 'Английский писатель-фантаст.');
INSERT INTO authors (name, biography) VALUES ('Агата Кристи', 'Королева детективов.');
INSERT INTO authors (name, biography) VALUES ('Лев Толстой', 'Русский писатель, автор "Войны и мира".');
INSERT INTO authors (name, biography) VALUES ('Айзек Азимов', 'Американский писатель-фантаст.');
INSERT INTO authors (name, biography) VALUES ('Джоан Роулинг', 'Британская писательница, автор "Гарри Поттера".');

INSERT INTO book (title, price, stock, genre_id, description, publication_date, author_id) 
VALUES ('2001: Космическая Одиссея', 500.00, 10, 1, 'Научная фантастика о космосе.', TO_DATE('1968-01-01', 'YYYY-MM-DD'), 1);

INSERT INTO book (title, price, stock, genre_id, description, publication_date, author_id) 
VALUES ('Убийство в Восточном экспрессе', 450.00, 5, 2, 'Детективный роман Агаты Кристи.', TO_DATE('1934-01-01', 'YYYY-MM-DD'), 2);

INSERT INTO book (title, price, stock, genre_id, description, publication_date, author_id) 
VALUES ('Война и мир', 1200.00, 7, 3, 'Эпопея о России во времена Наполеона.', TO_DATE('1869-01-01', 'YYYY-MM-DD'), 3);

INSERT INTO book (title, price, stock, genre_id, description, publication_date, author_id) 
VALUES ('Я, Робот', 600.00, 15, 1, 'Сборник рассказов об искусственном интеллекте.', TO_DATE('1950-01-01', 'YYYY-MM-DD'), 4);

INSERT INTO book (title, price, stock, genre_id, description, publication_date, author_id) 
VALUES ('Гарри Поттер и философский камень', 700.00, 20, 5, 'Начало приключений Гарри Поттера.', TO_DATE('1997-06-26', 'YYYY-MM-DD'), 5);

INSERT INTO employee (name, last_name, job) VALUES ('Алексей', 'Смирнов', 'Менеджер');
INSERT INTO employee (name, last_name, job) VALUES ('Ольга', 'Морозова', 'Кассир');
INSERT INTO employee (name, last_name, job) VALUES ('Дмитрий', 'Фёдоров', 'Складовщик');

INSERT INTO Orders (user_id, price, count, employee_id) VALUES (1, 500.00, 1, 1);
INSERT INTO Orders (user_id, price, count, employee_id) VALUES (2, 450.00, 2, 2);
INSERT INTO Orders (user_id, price, count, employee_id) VALUES (3, 1200.00, 1, NULL);
INSERT INTO Orders (user_id, price, count, employee_id) VALUES (4, 600.00, 1, 3);
INSERT INTO Orders (user_id, price, count, employee_id) VALUES (5, 700.00, 2, 1);

INSERT INTO orderdetails (order_id, product_id, count, date_order) 
VALUES (1, 1, 1, SYSTIMESTAMP);

INSERT INTO orderdetails (order_id, product_id, count, date_order) 
VALUES (2, 2, 2, SYSTIMESTAMP);

INSERT INTO orderdetails (order_id, product_id, count, date_order) 
VALUES (3, 3, 1, SYSTIMESTAMP);

INSERT INTO orderdetails (order_id, product_id, count, date_order) 
VALUES (4, 4, 1, SYSTIMESTAMP);

INSERT INTO orderdetails (order_id, product_id, count, date_order) 
VALUES (5, 5, 2, SYSTIMESTAMP);

INSERT INTO payments (order_id, sum) VALUES (1, 500.00);
INSERT INTO payments (order_id, sum) VALUES (2, 900.00);
INSERT INTO payments (order_id, sum) VALUES (3, 1200.00);
INSERT INTO payments (order_id, sum) VALUES (4, 600.00);
INSERT INTO payments (order_id, sum) VALUES (5, 1400.00);


-- Процедура 1: Добавление нового пользователя
CREATE OR REPLACE PROCEDURE add_user(
    p_name IN NVARCHAR2, 
    p_last_name IN NVARCHAR2, 
    p_email IN NVARCHAR2, 
    p_hash IN NVARCHAR2, 
    p_role IN NVARCHAR2
) AS
BEGIN
    INSERT INTO Users (name, last_name, email, hash, role)
    VALUES (p_name, p_last_name, p_email, p_hash, p_role);
END add_user;
/

-- Процедура 2: Обновление информации о книге
CREATE OR REPLACE PROCEDURE create_order(
    p_user_id IN NUMBER, 
    p_employee_id IN NUMBER, 
    p_price IN NUMBER, 
    p_count IN NUMBER
) AS
BEGIN
    INSERT INTO Orders (user_id, price, count, employee_id)
    VALUES (p_user_id, p_price, p_count, p_employee_id);
END create_order;
/

-- Процедура 3: Удаление заказа
CREATE OR REPLACE PROCEDURE delete_order(
    p_id_order IN NUMBER
) AS
BEGIN
    -- Сначала удаляем детали заказа, чтобы не нарушить ограничения внешнего ключа
    DELETE FROM orderdetails WHERE order_id = p_id_order;

    -- Затем удаляем сам заказ
    DELETE FROM Orders WHERE id_order = p_id_order;
END delete_order;
/

-- Процедура 4: Завершение заказа
CREATE OR REPLACE PROCEDURE get_order_info(
    p_id_order IN NUMBER
) AS
    v_user_id NUMBER;
    v_price NUMBER(10,2);
    v_count NUMBER;
    v_employee_id NUMBER;
BEGIN
    -- Получаем данные о заказе по его ID
    SELECT user_id, price, count, employee_id
    INTO v_user_id, v_price, v_count, v_employee_id
    FROM Orders
    WHERE id_order = p_id_order;

    -- Выводим информацию о заказе с помощью DBMS_OUTPUT
    DBMS_OUTPUT.PUT_LINE('Order ID: ' || p_id_order);
    DBMS_OUTPUT.PUT_LINE('User ID: ' || v_user_id);
    DBMS_OUTPUT.PUT_LINE('Price: ' || v_price);
    DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_employee_id);

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Order not found');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END get_order_info;
/


-- Процедура 5: Добавление нового жанра
CREATE OR REPLACE PROCEDURE add_genre(
    p_genre_name IN NVARCHAR2
) AS
BEGIN
    INSERT INTO genres (name) VALUES (p_genre_name);
END add_genre;
/

-- Добавление нового пользователя
EXEC add_user('qqqq', 'qqqq', 'qqqq@example.com', 'qqq', 'user');

-- Обновление информации о книге с id_book = 1
EXEC create_order(2, 1, 1000, 2);

-- Удаление книги с id_book = 2
EXEC delete_book(2);

-- Завершение заказа с id_order = 1
EXEC get_order_info(1);

-- Добавление нового жанра
EXEC add_genre('Мистика');


-- Функция 1: Получение полной стоимости заказа
CREATE OR REPLACE FUNCTION get_order_total(
    p_order_id IN NUMBER
) RETURN NUMBER AS
    v_total NUMBER := 0;
BEGIN
    SELECT SUM(b.price * od.count)
    INTO v_total
    FROM orderdetails od
    JOIN book b ON od.product_id = b.id_book
    WHERE od.order_id = p_order_id;
    RETURN v_total;
END get_order_total;
/

-- Функция 2: Получение количества книг по жанру
CREATE OR REPLACE FUNCTION get_books_count_by_genre(
    p_genre_name IN NVARCHAR2
) RETURN NUMBER AS
    v_count NUMBER := 0;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM book b
    JOIN genres g ON b.genre_id = g.id
    WHERE g.name = p_genre_name;
    RETURN v_count;
END get_books_count_by_genre;
/

-- Функция 3: Проверка наличия книги в наличии
CREATE OR REPLACE FUNCTION is_book_in_stock(
    p_id_book IN NUMBER
) RETURN NUMBER AS
    v_stock NUMBER;
BEGIN
    SELECT stock INTO v_stock FROM book WHERE id_book = p_id_book;
    IF v_stock > 0 THEN
        RETURN 1;  -- Книга есть в наличии
    ELSE
        RETURN 0;  -- Книги нет в наличии
    END IF;
END is_book_in_stock;
/


-- Функция 4: Получение полного имени пользователя
CREATE OR REPLACE FUNCTION get_full_user_name(
    p_user_id IN NUMBER
) RETURN NVARCHAR2 AS
    v_full_name NVARCHAR2(100);
BEGIN
    SELECT name || ' ' || last_name INTO v_full_name
    FROM Users
    WHERE id = p_user_id;
    RETURN v_full_name;
END get_full_user_name;
/

-- Функция 5: Получение общего количества заказанных товаров
CREATE OR REPLACE FUNCTION get_total_items_in_order(
    p_order_id IN NUMBER
) RETURN NUMBER AS
    v_total_items NUMBER := 0;
BEGIN
    SELECT SUM(count)
    INTO v_total_items
    FROM orderdetails
    WHERE order_id = p_order_id;
    RETURN v_total_items;
END get_total_items_in_order;
/

-- Получение полной стоимости заказа с id_order = 1
SELECT get_order_total(1) FROM DUAL;

-- Получение количества книг в жанре 'Фантастика'
SELECT get_books_count_by_genre('Фантастика') FROM DUAL;

-- Проверка наличия книги с id_book = 3 в наличии
SELECT is_book_in_stock(1) FROM DUAL;

-- Получение полного имени пользователя с id = 1
SELECT get_full_user_name(1) FROM DUAL;

-- Получение общего количества товаров в заказе с id_order = 1
SELECT get_total_items_in_order(1) FROM DUAL;
-- Подключение как SYSDBA
sqlplus sys/password@your_db as sysdba;

-- Создание нового пользователя
CREATE USER uuuser IDENTIFIED BY user;

-- Предоставление привилегий для подключения и создания объектов
GRANT CREATE SESSION TO uuuser;
GRANT CREATE TABLE TO uuuser;
GRANT CREATE VIEW TO uuuser;
GRANT CREATE PROCEDURE TO uuuser;
GRANT CREATE SEQUENCE TO uuuser;
GRANT CREATE TRIGGER TO uuuser;
GRANT CREATE ANY TABLE TO uuuser;
GRANT ALTER ANY TABLE TO uuuser;
GRANT DROP ANY TABLE TO uuuser;
GRANT SELECT ANY TABLE TO uuuser;
GRANT INSERT ANY TABLE TO uuuser;
GRANT UPDATE ANY TABLE TO uuuser;
GRANT DELETE ANY TABLE TO uuuser;

-- Назначение роли DBA (предоставляет полный доступ ко всем объектам и операциям в базе данных)
CREATE OR REPLACE TRIGGER trg_before_insert_user
BEFORE INSERT ON Users
FOR EACH ROW
BEGIN
    -- Приводим email к нижнему регистру
    :NEW.email := LOWER(:NEW.email);
    
    -- Выводим сообщение о добавлении пользователя
    DBMS_OUTPUT.PUT_LINE('Добавляется новый пользователь: ' 
                          || :NEW.name || ' ' || :NEW.last_name);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Ошибка в триггере: ' || SQLERRM);
END;
/


